/**
 * Next.js API Route: /api/predict
 * Predicts lap time from telemetry features
 * Works on both localhost and Vercel
 */

import { NextResponse } from 'next/server'

// Feature extraction helper
function extractFeatures(record) {
  // Check if aggregated features exist
  const hasAggregated = Object.keys(record).some(k => 
    k.endsWith('_mean') || k.endsWith('_std') || k.endsWith('_max')
  )
  
  if (hasAggregated) {
    // Use aggregated features directly
    return [
      record.accx_can_mean || record.accx_can || 0,
      record.accx_can_std || 0,
      record.accx_can_max || record.accx_can || 0,
      record.accy_can_mean || record.accy_can || 0,
      record.accy_can_std || 0,
      record.accy_can_max || record.accy_can || 0,
      record.ath_mean || record.ath || 0,
      record.ath_std || 0,
      record.ath_max || record.ath || 0,
      record.pbrake_r_mean || record.pbrake_r || 0,
      record.pbrake_r_std || 0,
      record.pbrake_r_max || record.pbrake_r || 0,
      record.pbrake_f_mean || record.pbrake_f || 0,
      record.pbrake_f_std || 0,
      record.pbrake_f_max || record.pbrake_f || 0,
      record.gear_mean || record.gear || 0,
      record.gear_std || 0,
      record.gear_max || record.gear || 0,
      record.Steering_Angle_mean || record.Steering_Angle || record.steering || 0,
      record.Steering_Angle_std || 0,
      record.Steering_Angle_max || record.Steering_Angle || record.steering || 0,
      record.nmot_mean || 0,
      record.nmot_std || 0,
      record.nmot_max || 0,
      record.cornering_aggression || 0,
      record.braking_intensity || 0,
      record.throttle_consistency || 0,
      record.track_length || 4.05,
      record.track_corners || 12,
      record.track_elevation || 50,
    ]
  } else {
    // Extract from raw telemetry
    const steering = record.Steering_Angle || record.steering || 0
    const speed = record.Speed || record.speed || 0
    
    return [
      record.accx_can || 0, 0, record.accx_can || 0,
      record.accy_can || 0, 0, record.accy_can || 0,
      record.ath || 0, 0, record.ath || 0,
      record.pbrake_r || 0, 0, record.pbrake_r || 0,
      record.pbrake_f || 0, 0, record.pbrake_f || 0,
      record.gear || 0, 0, record.gear || 0,
      steering, 0, steering,
      0, 0, 0, 0, 0, 0,
      4.05, 12, 50,
    ]
  }
}

// Simple prediction model (placeholder - can be replaced with ONNX/TFJS)
function predictLapTime(features) {
  // This is a simplified linear regression approximation
  // In production, load ONNX model or TensorFlow.js model
  // For now, use a heuristic based on feature importance
  
  const [
    accx_mean, accx_std, accx_max,
    accy_mean, accy_std, accy_max,
    ath_mean, ath_std, ath_max,
    pbrake_r_mean, pbrake_r_std, pbrake_r_max,
    pbrake_f_mean, pbrake_f_std, pbrake_f_max,
    gear_mean, gear_std, gear_max,
    steering_mean, steering_std, steering_max,
    nmot_mean, nmot_std, nmot_max,
    cornering_aggression, braking_intensity, throttle_consistency,
    track_length, track_corners, track_elevation
  ] = features
  
  // Base lap time for Sonoma (in seconds)
  let baseTime = 90.0
  
  // Adjust based on throttle (higher throttle = faster)
  const throttleFactor = 1.0 - (ath_mean / 100) * 0.1
  
  // Adjust based on braking (more braking = slower)
  const brakeFactor = 1.0 + ((pbrake_f_mean + pbrake_r_mean) / 100) * 0.05
  
  // Adjust based on speed consistency (lower std = faster)
  const consistencyFactor = 1.0 - (Math.min(ath_std / 20, 0.1))
  
  // Adjust based on track characteristics
  const trackFactor = 1.0 + (track_corners / 100) + (track_elevation / 1000)
  
  const predictedTime = baseTime * throttleFactor * brakeFactor * consistencyFactor * trackFactor
  
  return Math.max(75.0, Math.min(120.0, predictedTime)) // Clamp to reasonable range
}

export async function POST(request) {
  try {
    const body = await request.json()
    
    if (!body.data || !Array.isArray(body.data) || body.data.length === 0) {
      return NextResponse.json(
        { error: 'No data provided' },
        { status: 400 }
      )
    }
    
    // Check if data already contains model predictions (from dataset)
    // Your dataset has 'predicted_lap_time' column which was generated by your XGBoost model
    let hasModelPredictions = body.data.some(p => 
      p.predicted_lap_time !== undefined && 
      p.predicted_lap_time !== null && 
      !isNaN(p.predicted_lap_time)
    )
    
    let predictions = []
    let predictedLapTime = 0
    
    if (hasModelPredictions) {
      // Use actual model predictions from dataset
      predictions = body.data
        .map(p => p.predicted_lap_time)
        .filter(p => p !== undefined && p !== null && !isNaN(p))
      
      if (predictions.length > 0) {
        predictedLapTime = predictions.reduce((a, b) => a + b, 0) / predictions.length
      } else {
        // Fallback to heuristic if no valid predictions
        hasModelPredictions = false
      }
    }
    
    if (!hasModelPredictions || predictions.length === 0) {
      // Fallback: Use heuristic model (for raw telemetry without pre-computed predictions)
      const featuresList = []
      
      for (const point of body.data) {
        const features = extractFeatures(point)
        featuresList.push(features)
        const pred = predictLapTime(features)
        predictions.push(pred)
      }
      
      predictedLapTime = predictions.reduce((a, b) => a + b, 0) / predictions.length
    }
    const stdDev = Math.sqrt(
      predictions.reduce((sum, p) => sum + Math.pow(p - predictedLapTime, 2), 0) / predictions.length
    )
    const consistencyScore = Math.max(0, Math.min(100, 100 - (stdDev / predictedLapTime * 100)))
    
    // Compute behavior patterns
    // Use new calculated speed columns (priority: calculated > raw > aggregated > derived)
    const deriveSpeed = (record) => {
      // Priority 1: New calculated speed columns (convert km/h to mph)
      if (record.calculated_top_speed_kmh) {
        return record.calculated_top_speed_kmh * 0.621371 // Convert km/h to mph
      }
      if (record.raw_top_speed) {
        return record.raw_top_speed
      }
      if (record.calculated_avg_speed_kmh) {
        return record.calculated_avg_speed_kmh * 0.621371 // Convert km/h to mph
      }
      if (record.raw_avg_speed) {
        return record.raw_avg_speed
      }
      
      // Priority 2: Direct Speed values
      if (record.Speed || record.speed) {
        return record.Speed || record.speed
      }
      
      // Priority 3: Aggregated Speed if available
      if (record.Speed_mean || record.speed_mean) {
        return record.Speed_mean || record.speed_mean
      }
      
      // Priority 4: Derive from engine RPM and gear (rough estimate)
      if (record.nmot_mean && record.gear_mean && record.gear_mean > 0) {
        const estimatedSpeed = (record.nmot_mean / (record.gear_mean * 100)) * 0.6
        return Math.max(30, Math.min(150, estimatedSpeed))
      }
      
      // Priority 5: Derive from lap time and track length
      if (record.actual_lap_time && record.track_length) {
        const avgSpeed = (record.track_length / record.actual_lap_time) * 3600
        return Math.max(30, Math.min(150, avgSpeed))
      }
      
      return 0
    }
    
    const speeds = body.data.map(deriveSpeed)
    const avgSpeed = speeds.reduce((sum, s) => sum + s, 0) / speeds.length
    const peakSpeed = Math.max(...speeds, 0)
    
    // Use raw values if available, otherwise fall back to aggregated
    const avgBrake = body.data.reduce((sum, p) => 
      sum + (p.raw_pbrake_f_mean || p.pbrake_f_mean || p.pbrake_f || 0) + 
           (p.raw_pbrake_r_mean || p.pbrake_r_mean || p.pbrake_r || 0), 0) / body.data.length
    const avgThrottle = body.data.reduce((sum, p) => 
      sum + (p.raw_ath_mean || p.ath_mean || p.ath || 0), 0) / body.data.length
    
    // Check if we used model predictions or heuristic
    const predictionSource = hasModelPredictions ? 'xgb_model' : 'heuristic'
    
    return NextResponse.json({
      predicted_lap_time: predictedLapTime,
      consistency_score: consistencyScore,
      predicted_peak_speed: peakSpeed,
      behavior_pattern: {
        avg_speed: avgSpeed,
        avg_brake_pressure: avgBrake,
        avg_throttle: avgThrottle,
        braking_intensity: avgBrake > 50 ? 'high' : avgBrake > 20 ? 'medium' : 'low',
        acceleration_aggressiveness: avgThrottle > 80 ? 'high' : avgThrottle > 50 ? 'medium' : 'low'
      },
      predictions_count: predictions.length,
      prediction_source: predictionSource, // Indicates if using real model or heuristic
      note: hasModelPredictions 
        ? 'Using XGBoost model predictions from dataset' 
        : 'Using heuristic approximation (model predictions not available)',
      // Include additional metrics if available in dataset
      lap_efficiency: body.data[0]?.lap_efficiency || null,
      prediction_confidence: body.data[0]?.prediction_confidence || null,
      raw_rpm_peak: body.data[0]?.raw_rpm_peak || null,
      raw_throttle_usage: body.data[0]?.raw_throttle_usage || null
    })
    
  } catch (error) {
    console.error('Prediction error:', error)
    return NextResponse.json(
      { error: `Prediction error: ${error.message}` },
      { status: 500 }
    )
  }
}

